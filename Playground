import UIKit

class Stack {
    
    var selfvalue: [String] = []
    var peek: String {
        get {
            if selfvalue.count != 0 {
                return selfvalue[selfvalue.count-1]
            } else {
                return ""
            }
        }
    }
    var empty: Bool {
        get {
            return selfvalue.count == 0
        }
    }
    
    func push(value: String) {
        selfvalue.append(value)
    }
    
    func pop() -> String {
        var temp = String()
        if selfvalue.count != 0 {
            temp = selfvalue[selfvalue.count-1]
            selfvalue.remove(at: selfvalue.count-1)
        } else if selfvalue.count == 0 {
            temp = ""
        }
        return temp
    }
    
}

func Change (input : String) -> String {
    var Mod =  input.replacingOccurrences(of: "*", with: " * ")
    var Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "/", with: " / ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "^", with: " ^ ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "cos", with: " cos ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "sin", with: " sin ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "+", with: " + ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "√", with: " √ ")
    Mod1 = Mod
    Mod = Mod1.replacingOccurrences(of: "-", with: " - ")


    return Mod
}

extension String {

    var precedence: Int {
        get {
            switch self {
            case "+":
                return 4
            case "-":
                return 4
            case "*":
                return 3
            case "/":
                return 3
            case "^":
                return 2
            case "√":
                return 2
            case "sin":
                return 1
            case "cos":
                return 1
            case "(":
            return 0
            case ")":
                return 0
            default:
                return 100
            }
        }
    }
    
    var isOperator: Bool {
        get {
            return ("+ - * / sin cos ^ √ ( )" as NSString).contains(self)
        }
    }
    
    var isNumber: Bool {
        get {
            return !isOperator && self != "(" && self != ")"
        }
    }
    
    subscript (i: Int) -> Character {
        return self[index(startIndex, offsetBy: i)]
    }
    
    subscript (i: Int) -> String {
        return String(self[i] as Character)
    }
    
    subscript (r: Range<Int>) -> String {
        let start = index(startIndex, offsetBy: r.lowerBound)
        let end = index(startIndex, offsetBy: r.upperBound - r.lowerBound)
        return self[Range(start ..< end)]
    }
}
    

    
extension Array {
   func get(index: Int) -> Element {
        if 0 <= index && index < count {
            return self[index]
        } else {
            return 0 as! Element
        }
    }
}


class infixparser {
    
    
 func solve( expression: String) -> Double {
        
        let expression = expression
        let operatorStack = Stack()
        let operandStack = Stack()
        let tokens = expression.components(separatedBy: " ")
        
        for (index, token) in tokens.enumerated() {
            
            "\(token) at \(index)"
            
            if token.isNumber {
                operandStack.push(value: token)
            }
            
            if token.isOperator {
                while operatorStack.peek.precedence <= token.precedence {
                    if !operatorStack.empty {
                        var res = 0.0
                        switch operatorStack.peek {
                        case "+":
                            res = Double(operandStack.pop())! + Double(operandStack.pop())!
                        case "-":
                            res = Double(operandStack.selfvalue[operandStack.selfvalue.count-2])! - Double(operandStack.pop())!
                            operandStack.pop()
                        case "^":
                            res = pow (Double(operandStack.selfvalue[operandStack.selfvalue.count-2])!, Double(operandStack.pop())!)
                            operandStack.pop()
                        case "*":
                            res = Double(operandStack.pop())! * Double(operandStack.pop())!
                        case "/":
                            res = Double(operandStack.selfvalue[operandStack.selfvalue.count-2])! / Double(operandStack.pop())!
                            operandStack.pop()
                        case "√":
                            res = sqrt(Double(operandStack.pop())!)
                        case "sin":
                            res = sin (Double(operandStack.pop())!)
                        case "cos":
                            res = cos(Double(operandStack.pop())!)
                        default:
                            res = 0
                        }
                        "\(res) at \(index)"
                        operatorStack.pop()
                        operandStack.push(value: "\(res)")
                    }
                }
                operatorStack.push(value: token)
            }
         }
    
    
        while !operatorStack.empty {
            var res = 0.0
            switch operatorStack.peek {
            case "+":
                res = Double(operandStack.pop())! + Double(operandStack.pop())!
            case "-":
                res = Double(operandStack.selfvalue[operandStack.selfvalue.count-2])! - Double(operandStack.pop())!
                operandStack.pop()
            case "*":
                res = Double(operandStack.pop())! * Double(operandStack.pop())!
            case "/":
                res = Double(operandStack.selfvalue[operandStack.selfvalue.count-2])! / Double(operandStack.pop())!
                operandStack.pop()
            case "sin":
                res = sin(Double(operandStack.pop())!)
            case "cos":
                res = cos(Double(operandStack.pop())!)
            case "√":
                res = sqrt(Double(operandStack.pop())!)
            case "^":
                res = pow (Double(operandStack.selfvalue[operandStack.selfvalue.count-2])!, Double(operandStack.pop())!)
                operandStack.pop()
            default:
                res = 0
            }
            operatorStack.pop()
            operandStack.push(value: "\(res)")
        }
        
        
        return Double(operandStack.pop())!
        
    }
    
}
let expr = "8/9/2"
let expr1 = Change(input: expr)
var parser = infixparser()
parser.solve(expression: expr1)


